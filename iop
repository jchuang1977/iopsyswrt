#!/bin/bash

arg=$1
arr_index=0
declare -a command_array
declare -a help_array


# Check if we should clone feeds with ssh or http
developer=0
which git >/dev/null && git remote -v 2>/dev/null | grep -qE '(git@|ssh://)' && developer=1


# Utility functions
function register_command {

    command_array[$arr_index]=$1
    help_array[$arr_index]=$2
    arr_index=$((arr_index+1))
}

function dump_commands {

    printf "Available commands:\n"
    for i in $(seq 0 $arr_index); do
        printf "   %-25s%s\n" "${command_array[$i]}" "${help_array[$i]}"
    done
}

# Register bootstrap command that installs other commands from feeds
function bootstrap {

    if [ $developer == 1 ]; then
        ./scripts/feeds update -g
    else
        ./scripts/feeds update
    fi

    ./scripts/feeds install -p iopsys iop
}

register_command "bootstrap" "Initial command to run to install other commands"

function install_locales()
{
    sudo locale-gen en_US.UTF-8
}

function install_pkgs()
{
    local packages_misc="
bc
bison
build-essential
ccache
cpio
curl
device-tree-compiler
dialog
execstack
file
flex
g++
g++-multilib
gawk
gdisk
gettext
git
automake
gtk-doc-tools
jq
liblzo2-dev
libncurses5
libncurses5-dev
libssl-dev
ncurses-term
pv
python
rsync
subversion
svn-buildpackage
swig
unzip
uuid-dev
wget
zlib1g-dev
xxd
cmake
quilt
cryptsetup
libcap-dev
libseccomp-dev
libyajl-dev
"
    local packages_perl="libconvert-binary-c-perl libdigest-crc-perl"

    # do we need 32 bit compatibility libs ?
    if [ "$(uname -m | awk '{print$1}')" == "x86_64" ]; then
	local packages_x64="libc6-dev-i386 lib32z1 libncurses5:i386"
    fi

    # filter out already installed packages
    local packages_all="$packages_misc $packages_perl $packages_x64"
    local needed=""

    for pkg in $packages_all
    do
	if ! dpkg -s $pkg >/dev/null 2>/dev/null
	then
	    needed="$needed $pkg"
	fi
    done

    # install needed packages
    if [ -n "$needed" ]
    then
	echo "Need to install dpkg packages [$needed]"
	read -p "Do you approve installation of these packages (y/n): " ans
	if [ "$ans" == "y" ]; then
	    sudo apt-get install $needed
	else
	    echo "can't continue. aborting!"
	    exit 1
	fi
    fi
}

check_bash()
{
    local mysh=$(ls -hl /bin/sh | awk -F'[ ,/]' '{print$NF}')
    if [ "$mysh" != "bash" ]; then
	echo "On Debian based systems, e.g. Ubuntu, /bin/sh must point to bash instead of $mysh"
	read -p "Do you approve this change (y/n): " ans
	if [ "$ans" == "y" ]; then
	    sudo rm -f /bin/sh
	    sudo ln -s bash /bin/sh
	else
	    echo "Warning! You haven't pointed /bin/sh to bash."
	    exit 1
	fi
    fi
}

download_extract_brcm_toolchain() {
    local url="$1"
    local sha256="$2"
    local path="$3"
    local tarball="$(mktemp iop_brcm_tar.XXXXXXX)"
    wget -nv "$url" -O "$tarball"
    if ! sha256sum -c <(echo "${sha256} *${tarball}"); then
        echo "Hash mismatch of tarball $url (expected: $sha256)"
        sha256sum "$tarball"
        rm -f $tarball
        exit 1
    fi
    # current 9.2/4.19/2.30/2.32 BCM toolchain has owner of files set to some employee who created the tar
    # Change to root during extraction
    if [ -z "$path" ]; then
        # tarballs have /opt/toolchains in them, hence the -P and no -C
        sudo tar --owner=root --group=root -Pxf "$tarball"
    else
        # the eabi toolchain is packed a bit differently
	sudo mkdir -p "$path"
        sudo tar --owner=root --group=root -C "$path" -xf "$tarball" --strip-components=1
    fi
    rm -f "$tarball"
}

check_brcm_tools(){
    local install_arm=0
    local install_aarch64=0
    local install_eabi=0

    if [ ! -d /opt/toolchains/crosstools-arm-gcc-9.2-linux-4.19-glibc-2.30-binutils-2.32 ]; then
        install_arm=1
        echo "Need to install Broadcom ARM toolchain"
    fi

    if [ ! -d /opt/toolchains/crosstools-aarch64-gcc-9.2-linux-4.19-glibc-2.30-binutils-2.32 ]; then
        install_aarch64=1
        echo "Need to install Broadcom aarch64 toolchain"
    fi

    if [ ! -d /opt/toolchains/hndtools-armeabi-2013.11 ]; then
        install_eabi=1
        echo "Need to install Broadcom eabi toolchain"
    fi

    if [ $install_arm -eq 1 -o $install_aarch64 -eq 1 -o $install_eabi -eq 1 ]; then
        read -p "Do you approve installation of missing toolchains (y/n): " ans
        if [ "$ans" == "y" ]; then
            echo "Downloading toolchain"
        else
            echo "can't continue. aborting"
            exit 1
        fi

        # create install dir
        sudo mkdir -p /opt/toolchains/

        if [ $install_arm -eq 1 ]; then
            echo "Installing ARM toolchain"
            download_extract_brcm_toolchain \
                https://download.iopsys.eu/iopsys/toolchain/crosstools-arm-gcc-9.2-linux-4.19-glibc-2.30-binutils-2.32.Rel1.12.tar.bz2 \
                1b5118bd3e9488f5436fb1e94f5837d2cc7b6e1c45db04e5966969a46942403f
        fi
        if [ $install_aarch64 -eq 1 ]; then
            echo "Installing aarch64 toolchain"
            download_extract_brcm_toolchain \
                https://download.iopsys.eu/iopsys/toolchain/crosstools-aarch64-gcc-9.2-linux-4.19-glibc-2.30-binutils-2.32.Rel1.12.tar.bz2 \
                2f60b8e01e02c928481ff3fb47052a7134c0499c1ccc26a9ddfb8b527008a115
        fi
        if [ $install_eabi -eq 1 ]; then
            echo "Installing eabi toolchain"
            download_extract_brcm_toolchain \
                https://download.iopsys.eu/iopsys/toolchain/arm-2013.11-24-arm-none-eabi-i686-pc-linux-gnu.tar.bz2 \
                752a0928b220ff209e3facb20df09e53e6493285ac8b620723edab7eadb1ba8a \
                /opt/toolchains/hndtools-armeabi-2013.11
        fi
    fi
}

check_gcc_version(){

    gcc_ver=$(ls -l $(which gcc) | awk '{ print $NF }')

    # if /usr/bin/gcc -> /etc/alternatives/cc
    if [ -L $gcc_ver ]; then
	gcc_ver=$(ls -l $gcc_ver | awk '{ print $NF }')
    fi

    # transform gcc-* to just a number.
    gcc_ver=$(echo $gcc_ver | cut -d- -f2)

    if [ "$gcc_ver" != 4.8 ]; then
	echo "Your current gcc version is $gcc_ver, but it must be changed to 4.8"
	read -p "Do you approve this change (y/n): " ans
	if [ "$ans" == "y" ]; then
	    if ! dpkg -s gcc-4.8 >/dev/null 2>/dev/null ;then
		sudo apt-get install gcc-4.8
	    fi
	    if ! dpkg -s g++-4.8 >/dev/null 2>/dev/null ;then
		sudo apt-get install g++-4.8
	    fi
	    if ! dpkg -s gcc-4.8-multilib >/dev/null 2>/dev/null ;then
		sudo apt-get install gcc-4.8-multilib
	    fi

	    sudo update-alternatives --install /usr/bin/g++ c++ /usr/bin/g++-4.8 100
	    sudo update-alternatives --install /usr/bin/g++ c++ /usr/bin/g++-$gcc_ver 90

	    sudo update-alternatives --install /usr/bin/gcc cc /usr/bin/gcc-4.8 100
	    sudo update-alternatives --install /usr/bin/gcc cc /usr/bin/gcc-$gcc_ver 90

	    sudo update-alternatives --install /usr/bin/cpp cpp /usr/bin/cpp-4.8 100
	    sudo update-alternatives --install /usr/bin/cpp cpp /usr/bin/cpp-$gcc_ver 90

	    sudo update-alternatives --set c++ /usr/bin/g++-4.8
	    sudo update-alternatives --set cc  /usr/bin/gcc-4.8
	    sudo update-alternatives --set cpp /usr/bin/cpp-4.8
	    sudo ln -s /etc/alternatives/cc /usr/bin/cc 

	    echo "The deafult gcc version has now been changed from $gcc_ver to 4.8"
	fi
    fi
}

restore_gcc() {
    if dpkg -s gcc-5 >/dev/null 2>/dev/null
    then
	gcc_ver=$(ls -l $(which gcc) | awk '{ print $NF }')

	# if /usr/bin/gcc -> /etc/alternatives/cc
	if [ -L $gcc_ver ]; then
	    gcc_ver=$(ls -l $gcc_ver | awk '{ print $NF }')
	fi

	# transform gcc-* to just a number.
	gcc_ver=$(echo $gcc_ver | cut -d- -f2)

	# is 4.8 the default reset back to 5 
	if [ "$gcc_ver" = "4.8" ]; then
	    echo "Your current gcc version is $gcc_ver that is not the distro default. set it back to default ?"
	    read -p "Do you approve this change (y/n): " ans
	    if [ "$ans" == "y" ]; then
		sudo update-alternatives --set c++ /usr/bin/g++-5
		sudo update-alternatives --set cc  /usr/bin/gcc-5
		sudo update-alternatives --set cpp /usr/bin/cpp-5

		# force a reinstall of default version
		# yes it needs to be done twice.
		sudo apt-get install --reinstall gcc cpp g++
		sudo apt-get install --reinstall gcc cpp g++
	    fi
	fi
    fi
}

# Compare modification date of two files
# return 0 (true) if first file is older, 1 (false) otherwise
is_older() {
    local target=$(stat -c %Y $1 2> /dev/null)
    local ref=$(stat -c %Y $2 2> /dev/null)

    [ -z "$target" -o -z "$ref" ] && return 1
    [ $target -lt $ref ] && return 0
    return 1
}

install_iop_completion() {
    local instloc=/usr/share/bash-completion/completions/iop
    local srcloc=./feeds/iopsys/iop/iop.completion
    local inst=0

    if [ ! -e $instloc ]; then
        echo "Bash completion for './iop' utility not found"
        inst=1
    elif is_older $instloc $srcloc ; then
        echo "Bash completion for './iop' utility is outdated"
        inst=1
    fi

    if [ $inst -eq 1 ]; then
        read -p "Install latest version to '$instloc' (y/n): " ans
        if [ "$ans" == "y" ]; then
            sudo cp $srcloc $instloc
            echo "Start a new shell to enable ./iop command completion!"
        fi
    fi
}

function setup_host {

    #===============#
    # Prerequisites #
    #===============#

    install_locales
    install_pkgs
    check_bash
    check_brcm_tools
    #check_gcc_version
    restore_gcc
    install_iop_completion

    echo ""
    echo ""
    echo "You have successfully installed and configred prerequisites to be able to build an iopsys firmware"
    echo ""
    echo ""
}

register_command "setup_host" "Install needed packets to host machine"


# Plugin scripts call register command to export their interface
if [ -d package/feeds/iopsys/iop/scripts ]; then

    for f in package/feeds/iopsys/iop/scripts/*; do
	source $f
    done
fi

if [ -z $arg ] || [ $arg == "--help" ]; then
    printf "Usage: iop <command> [<args>]\n\n"
    dump_commands
    exit -1
fi

# Check all registered commands for a match
for i in $(seq 0 $arr_index); do

    if [ $arg == "${command_array[$i]}" ]; then
        # Run the command and pass all args 
        # except for the first to it
        $arg "${@:2}"
        exit 0
    fi

done


# No registered command for the passed input arg
printf "Error: no such command $arg\n\n"
dump_commands
exit -1
